<?php

/**
* OpenAPI spec version: 0.0.1
*
*
* NOTE: This class is auto generated by the swagger code generator program.
* https://github.com/swagger-api/swagger-codegen.git
* Do not edit the class manually.
*/


namespace App\Http\Controllers\Api\V1;

use Illuminate\Support\Facades\Request;
use App\Models\User;
use \Firebase\JWT\JWT;
use App\Http\Utils\Utils;
use Illuminate\Support\Facades\Hash;

use Log;
use App\Models\Business;

class AuthenticationApiImpl extends AuthenticationApi
{
    /**
    * Constructor
    */
    public function __construct()
    {
    }


    /**
    * Operation forgot
    *
    * Assign new temporary password.
    *
    *
    * @return Http response
    */
    public function forgot()
    {
        $input = Request::all();
        $body = json_decode( Request::instance()->getContent() );

        //path params validation
        $user = User::where('email', strtolower($body->email))->first();

        if( $user != null ) {
            $newPassword = Utils::generatePassword();
            $user->password = Hash::make($newPassword);
            $user->save();
            // Send email
            $emailContent = 'Un mot de passe temporaire vient de vous être attribué : ' . $newPassword .' suite à votre demande.<br/> S\'il s\'agit d\'une erreur, vous pouvez supprimer cet email.';
            $data = Utils::sendEmail(  $user->email, 'Nouveau mot de passe sur ' . env('APP_NAME'), $emailContent);
        } else {
            return response()->json(['error' => 'Not found'], 404);
        }


        return response()->json(['success' => true]);
    }
    /**
    * Operation login
    *
    * Register a new user.
    *
    *
    * @return Http response
    */
    public function login()
    {
        $input = Request::all();
        $body = json_decode( Request::instance()->getContent() );


        // check if this email already exists
        if( $body->password ) {
            $password = Hash::make($body->password);
        }
        else {
            return response()->json(['error' => 'User not found'], 404);
        }
        $user = User::where('email',  strtolower($body->email))->first();

        // Calculate token expiration
        $expiration = time() + env('JWT_EXPIRATION_IN_SECONDS');
        $type = 'user';

        if( !$user ) {
            // check business
            $user = Business::where('email',  strtolower($body->email))->first();
            $type = 'business';
            if (!$user) {
                // User does not exist, so returning error
                return response()->json(['error' => 'User not found'], 404);
            }
        }
          // check hash
        if (Hash::check($body->password, $user->password)) {
            // The passwords match...
            // Generate token
            $token = array(
                "exp" => $expiration,
                "userId" => $user->id,
                "role" => $type == 'business' ? 'business' : $user->role,
                "type" => $type
            );
        } else {
            return response()->json(['error' => 'Wrong password'], 404);
        }

        // encode token
        $jwt = JWT::encode($token, env('JWT_PRIVATE'));
        // $decoded = JWT::decode($jwt, env('JWT_PRIVATE'), array('HS256'));
        // Log::debug(var_dump($decoded, true));

        unset($user->password);

        $user->type = $type;
        return response()->json([
            "token" => $jwt,
            "tokenExpiration" => $expiration,
            "user" => $user,
            "type" => $type
        ]);
    }
    /**
    * Operation regenerate
    *
    * Regenerate the current auth token.
    *
    *
    * @return Http response
    */
    public function regenerate()
    {
        // $token = Utils::isAuthorized((array)[
        //     'role' => array('employee', 'admin'),]);
        $input = Request::all();


        // if( !isset($token) ) {
        //     $unauthorized = Utils::unauthorizedMessage();
        //     return response()->json($unauthorized->message, $unauthorized->status);
        // }

        $decodedToken = Utils::decodeExpiredToken();

        if( $decodedToken == null ) {
            $unauthorized = Utils::unauthorizedMessage();
            return response()->json($unauthorized->message, $unauthorized->status);
        }

        // If user is admin, regenerate directly
        if( isset( $decodedToken->admin ) && $decodedToken->admin == true ) {
            $decodedToken->iat = time();
            if( isset($input['expire_in'])) {
                $decodedToken->exp = time() + min( intval($input['expire_in']), env('JWT_EXPIRATION_IN_SECONDS'));
            }
            else {
                $decodedToken->exp = time() + env('JWT_EXPIRATION_IN_SECONDS');
            }

            return response()->json([
            "token" => JWT::encode((array)$decodedToken, env('JWT_PRIVATE')),
            "tokenExpiration" => $decodedToken->exp
            ]);
        }

        // Check in DB if user exists
        $type = 'user';
        $user = User::find($decodedToken->userId);

        if ( $user == null ) { // TODO: check another need parameters
            $type = 'business';
            $user = Business::find($decodedToken->userId);
            if (!$user) {
                $notFound = Utils::notFoundMessage();
                return response()->json($notFound->message, $notFound->status);
            }
        }
        if ($user->archived === true) {
            return response()->json(['error' => 'User archived'], 405);
        }

        $decodedToken->iat = time();
        if( isset($input['expire_in'])) {
            $decodedToken->exp = time() + min( intval($input['expire_in']), env('JWT_EXPIRATION_IN_SECONDS'));
        }
        else {
            $decodedToken->exp = time() + env('JWT_EXPIRATION_IN_SECONDS');
        }
        return response()->json([
        "token" =>  JWT::encode((array)$decodedToken, env('JWT_PRIVATE')),
        "tokenExpiration" => $decodedToken->exp
        ]);
    }
    /**
     * Operation register
     *
     * Register a user.
     *
     *
     * @return Http response
     */
    public function register()
    {
        $input = Request::all();
        $body = json_decode( Request::instance()->getContent() );

        // check if this email already exists
        if (isset($body->email)) {
            $user = User::where('email', $body->email)->first();

            if ($user) {
                // User already exists, so returning error
                return response()->json(['error' => 'Email already in use'], 409);
            }
        }
        if (isset($body->phone)) {
            $user = User::where('phone', $body->phone)->first();

            if ($user) {
                // User already exists, so returning error
                return response()->json(['error' => 'Phone already in use'], 409);
            }
        }
        $user = new User((array) $body);
        if (isset($body->password) && strlen($body->password) > 0) {
            $user->password = Hash::make($body->password);
        }
        $user->role = 'user';
        $user->save();
        // Calculate token expiration
        $expiration = time() + env('JWT_EXPIRATION_IN_SECONDS');
        

        if( !$user ) {
            // User does not exist, so returning error
            return response()->json(['error' => 'User not registerd'], 404);
        } else {
            $token = array(
                "exp" => $expiration,
                "userId" => $user->id,
                "role" => $user->role,
                "type" => 'user'
            );
            
        }

        // encode token
        $jwt = JWT::encode($token, env('JWT_PRIVATE'));
        // $decoded = JWT::decode($jwt, env('JWT_PRIVATE'), array('HS256'));
        // Log::debug(var_dump($decoded, true));

        unset($user->password);
        $user->type = 'user';
        return response()->json([
            "token" => $jwt,
            "tokenExpiration" => $expiration,
            "user" => $user
        ]);
    }
    /**
     * Operation registerPro
     *
     * Register a pro user.
     *
     *
     * @return Http response
     */
    public function registerPro()
    {
        $input = Request::all();
        $body = json_decode( Request::instance()->getContent() );

        // check if this email already exists
        if (isset($body->email)) {
            $business = Business::where('email', $body->email)->first();

            if ($business) {
                // User already exists, so returning error
                return response()->json(['error' => 'Email already in use'], 409);
            }
        }
        if (isset($body->phone)) {
            $business = Business::where('phone', $body->phone)->first();

            if ($business) {
                // User already exists, so returning error
                return response()->json(['error' => 'Phone already in use'], 409);
            }
        }
        $business = new Business((array) $body);
        if (isset($body->password) && strlen($body->password) > 0) {
            $business->password = Hash::make($body->password);
        }
        // $business->role = 'user';
        $business->save();
        // Calculate token expiration
        $expiration = time() + env('JWT_EXPIRATION_IN_SECONDS');
        

        if( !$business ) {
            // User does not exist, so returning error
            return response()->json(['error' => 'User not registerd'], 404);
        } else {
            $token = array(
                "exp" => $expiration,
                "userId" => $business->id,
                "role" => 'user',
                "type" => 'business'
            );
            
        }

        // encode token
        $jwt = JWT::encode($token, env('JWT_PRIVATE'));
        // $decoded = JWT::decode($jwt, env('JWT_PRIVATE'), array('HS256'));
        // Log::debug(var_dump($decoded, true));

        unset($business->password);
        $business->type = 'business';
        return response()->json([
            "token" => $jwt,
            "tokenExpiration" => $expiration,
            "user" => $business,
            "type" => 'business'
        ]);
    }
}
